Лабораторная работа № 9
Односвязные списки

1. ЦЕЛЬ РАБОТЫ:  изучение ссылочных типов данных, работа с односвязными       списками.

    2. Основные сведения

Динамический список – это последовательность структур, каждая из которых содержит ссылку, связывающую её с другой структурой. Для организации списков используются структуры, состоящие из двух смысловых частей – информационной  и дополнительной. Информационная часть содержит подлежащую обработке информацию, в дополнительной  находятся указатели на последующую или предыдущую структуру списка:
	Struct st {   char data[20];
                                 struct st  *next; };  // Указатель на структуру st
Здесь при описании указателя используем ещё не описанный объект struct st *next , который будет служить ссылкой на соседний элемент списка. В зависимости от метода доступа к элементам линейного списка различают разновидности линейных списков. Наиболее известны списки, называемые стеком и очередью. Стек можно представить как стопку книг на столе, где добавление или взятие новой книги возможно только сверху. Таким образом, операции добавления и удаления элемента, а также доступа к элементу выполняются только в конце списка. Очередь - это список, где элементы удаляются из начала списка, а добавляются в конец списка (как обыкновенная очередь в магазине). 
Пример создания и просмотра стека.  Пусть требуется ввести некоторую последовательность символов, заканчивающуюся точкой, и напечатать ее в обратном порядке
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
typedef struct st         
    { char ch;
      struct st *next;   
    } stack;
  main()
  {   stack *p,*q;
      char a;
      p=NULL;
      system (“CLS”);     
//  заполнение стека 
      do           
      { a=getchar();
        q=(stack *)malloc(sizeof(stack));
         q->next=p; 
         p=q;
         q->ch=a;
      }  while(a!='.');
//  печать стека c освобождением памяти
      do        
      { p=q->next;
        free(q);
        q=p;
        printf("%c",p->ch);
      } while(p->next!=NULL);
      getch();
      return 0;
  }


Пример создания и просмотра односвязного списка. Пусть требуется поместить в список фамилии и вывести их в порядке очерёдности. В данном примере используем операторы new и delete. 


#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
typedef struct st
     { char data[20];
       struct st *next;} spis;
spis * create(void); //функция создания списка
void list(spis *head); // функция просмотра списка
void free_spis(spis *head); //функция освобождения памяти
main()
{ system ("CLS");
  spis *head; // адрес головы списка
  head= create();
   list (head);
   free_spis (head);
   getch(); 
} 
 spis * create(void)
{  spis *p, *pred, *h; 
   // pred – указатель на предыдущую структуру
  // h- указатель на первую структуру
   h=pred=new spis; //выделение памяти для первой структуры
   printf("  fam: "); scanf("%s", pred->data);
   do { p=new spis;
        printf("\n  fam: "); scanf("%s", p->data);
        pred->next=p; //ссылка из предыдущей на текущую
        pred=p; // сохранение адреса текущей 
        printf(" закончить? y/n  ");
       } while (getch()='y');
   p->next=NULL; 
   return h;
}
void list(spis *head)
{  spis *p;
   p=head;
   while (p!=NULL) // пока не конец списка
   {  printf("\n  fio: %s",p->data);
      p=p->next; // продвижение по списку 
   }
}   
 void free_spis(spis *head)
 { spis *p,*q;
   q=p=head;
   while (p!=NULL)
   {
     p=q->next;
     delete q; 
     q=p;
   }   
  head=NULL;
 }

    3. Выполнение работы

    1. Сформировать односвязный список, состоящий из структур, содержащих информацию: фамилия студента и 4 оценки. При формировании списка предусмотреть, чтобы он был упорядочен по возрастанию (по фамилии). Вывести полученный список.
    2.  Найти и удалить из списка студентов, имеющих хотя бы одну неудовлетворительную оценку. Вывести откорректированный список.
    3. Освободить память, занятую списком.
