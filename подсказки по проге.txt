Процедура - функция с типом возвр зн void.

#include <iostream>//for cout(for C++ only)// char будет выведен именно буквами, а не численными значениями
using namespace std;// for cout(for C++ only)
#include<stdlib.h>// for srand
#include<conio.h>//for _getch()

The Win32 templates have been renamed to Windows Desktop in Visual Studio

typedef struct st {
 struct st *next;
} slist;
это вроде как равносильно этому:
 struct st {
	struct st *next;
} ;
 typedef st slist;
 Вроде как небольшие отличия есть, но по Подбельскому/Фомину единственное отличие st и stlist(в обоих способах объявления)
 в том, что для выделения памяти под структуру можно писать struct st name; и stlist name; 
 Т.е. typedef просто позволяет избавиться от слова struct при инициализациях.

Visual Assist расширение для подсказок(есть только прбная версия(потом отключается))

По аналогии со стопкой тарелок начало списка называют основанием стека, а его конец — вершиной.

srand(NULL);
int random(int N) { return rand() % N; }
a[i] = random(b - a + 1) + a;
/* 
разобрался наконец-то как это работает. 
Сюда подаётся N, которая представляет из себя отличие а от b. 
От rand() в итоге отсекается число* 
...пока могу думать только о положительных... так ранд только положительные и выдаёт...
*от нуля до b-a(например если а = -5,
b = 10, то rand() % N; выдаст число от нуля до 15. В вызывающем методе ещё прибавится а, т.е. -5.
Т.о. и выдаётся результат от -5 до 10.*/
a[i] = random(b - a + 1) + a;// +1 нужен, видимо для включения границы b, иначе остатком выдавало бы
число меньшее b на 1.

p[i] = (float)rand()*(n - m) / RAND_MAX + m;

o(f), «о малое отf» обозначает «бесконечно малое относительно f»[1], пренебрежимо малую величину при рассмотренииf. Смысл термина «О большое» зависит от его области применения, но всегда g = O(f) растёт не быстрее, чемf (точные определения приведены ниже).

В частности:

фраза «сложность алгоритма естьO(f(n))» означает, что с увеличением параметра n, характеризующего количество входной информации алгоритма, время работы алгоритма будет возрастать не быстрее, чем некоторая константа, умноженная на f(n);
фраза «функция f(x) является „о“ малым от функцииg(x) в окрестности точки p» означает, что с приближением x к p f(x) уменьшается быстрее, g(x) (отношение|f(x)|/|g(x)|стремится к нулю).

char str[4] = {"e2e4"};
printf("%d", (int)str[1]);// Выдаст аски код цифры 2

Если выдаёт warning из-за использования deprecated функций:
Project->Properties->c/c++->Preprocessor->Добавить _CRT_SECURE_NO_WARNINGS; в Preprocessor Definitions
Так же может помочь #pragma warning(disable : 4996)

float *p; // указатель на вещественные числа 
 p=(float *) malloc(n*sizeof(float));// Выделяемпамять под n 
вещественных чисел;
 for (i=0;i<n;i++)
 Доступ существляется через p[i]
	
	Чтобы ввести строку через консоль cin>>str; не сработает(пробелы воспринимает как конец ввода). Нужно так
#include <iostream>
#include <string>
 string mystr;
 getline (cin, mystr);// хотя у меня так не сработало... сработало так:
 char text[200];
 cin.getline(text , 200);
 
#include <locale.h> 
setlocale (LC_ALL, "RUS"); 

int c;
int *p = &c;
Вот пример простой с присвоением указателю p адреса c.

Чтобы пользоваться внешней переменной без указания звёздочки:
void f(int &c){c=10;}

In Russian "parameters" are called "formal parameters", while "arguments" are called "actual parameters".
argument is the one you use it, while parameter is a blank to be filled in

void swap(int *xp, int *yp)
{
	int temp = *xp;
	*xp = *yp;
	*yp = temp;
}
swap(&arr[j], &arr[j + 1]);

void iswap(int &n1, int &n2) {
	int temp = n1;
	n1 = n2;
	n2 = temp;
}
iswap(a[i + sh], a[i * 2 + 2 + sh]);

tmp = arr[i];// самый простой способ
arr[i] = arr[j];
arr[j] = tmp;

QuickSort из методички работает

char **AddPtr (char **pp, int size, char *str); //прототип функции //Интересный прототип... без имени?

Бился с передачей массива указателей на указатели. Оказалось, что звёздочки должны быть впереди при передаче
void boardGeneration(char **a)
Хотя так тоже работало void boardGeneration(char a[][9]), но выдавало предупреждение при компиляции 
 note: expected 'char (*)[9]' but argument is of type 'char **'
 илиwarning: passing argument 1 of 'boardRenew' from incompatible pointer type [-Wincompatible-pointer-types]
 
 Notepad++ Опции-определение стиля-можно поменять цвет фона, текста
 
 Settings -> Preferences dialog control the way Notepad++ prints a document: Print - Colour and Margin and Print - Header and Footer.
The former lets you choose the four margins, in centimeters. There are also four colour schemes to choose from:
actual colours
inverted actual colours
black on white
actual foreground on white.

Нулевой символ(asci = 0?) автоматически добавляется в строку str после прочитанных символов, чтобы сигнализировать о конце строки.

Вот у Вас есть переменная int a. Это такая буковка, с помощью которой компилятор умеет определить, о чём Вы ему говорите. Он знает, что за буковкой a кроется значение в памяти, расположенное по какому-то адресу (адрес в памяти — это число). Ну, Вы же понимаете, что переменная — это такая штука, чтобы удобно по имени обращаться к данным, записанным в определённом участке памяти.

Так вот, указатель — это, тупо, то самое число, тот самый адрес. Т.е. &a равно именно в точности адресу в памяти, по которому хранится значение. Чтобы избежать невнятных проблем, тип «указатель на int (или на любой другой тип) — int*» — это такой совершенно отдельный тип.

Итак есть два волшебных оператора: * и &. Второй по данной переменной узнаёт её адрес в памяти. Первый по данному адресу (который, как мы помним, хранится в переменной типа int*) возвращает собственно данные, расположенные по этому адресу.

#include<cstdlib>// for rand
#include<cstdlib>// for rand
#include<conio.h>// for _getch()


Натуральные числа a и b называют взаимно простыми, если их наибольший общий делитель равен 1

int Hash1(char(*arr)[8], int n);
char arr[n][8]; // двумерный массив статическое выделение памяти
Hash1(arr,n); // n - константа

mod = modulus = модуль

*& - это ссылка на указатель. Используется в С++ как альтернатива двойному указателю. К примеру, для инициализации указателя.
void someFunc(someType *& param) 
{
 someType * result = NULL;
 // Выполняем некоторые действия.
 param = result;
}
void someFunc(someType ** param) 
{
 someType * result = NULL;
 // Выполняем некоторые действия.
 *param = result;
}
Эти функции эквиваленты

чтобы винда после установки обновлений не переходила в спящий режим каждые 3 минуты нужно 
сбросить настройки сна до заводских (в продвинутых настройках). Также поставить значение 2 в regedit
HKEY_LOCAL_MACHINE > SYSTEM > CurrentControlSet > Control > Power > PowerSettings > 238C9FA8-0AAD-41ED-83F4-97BE242C8F20 > 7bc4a2f9-d8fc-4469-b07b-33eb785aaca0 Attributes 
потом всё равно в одной из настроек будет 2 минуты. Можно поменять на 0.

Чтобы в винде не сбивалось время из-за конфликта с линуксом в цмд написать:
Reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v RealTimeIsUniversal /t REG_QWORD /d 1
sc config w32time start= disabled
чтобы отменить:
Reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 0
sc config w32time start= demand
https://losst.ru/sbivaetsya-vremya-v-ubuntu-i-windows
ну и ещё раз пришлось переустановить время после перезагрузки

Если выключается вместо перехода в спящий режим:
Зашел в параметры питания, вкладка Сон, Разрешить Гибридный сон (ВКЛ) и все, вуаля. 

build - папка для объектных временных файлов-кусочков для сборки программы
bin - папка для исполняемых файлов(.exe например)

1 семестр 2-го курса
Э МАТЕМАТИКА
Э МАТЕМАТИЧЕСКАЯ ЛОГИКА И ТЕОРИЯ АЛГОРИТМОВ
Э ОБЪЕКТНО–ОРИЕНТИРОВАННОЕ ПРОГРАММИРОВАНИЕ
Э САОД
ИНТЕРНЕТ ТЕХНОЛОГИИ
ЭЛЕКТРОТЕХНИКА, ЭЛЕКТРОНИКА, СХЕМОТЕХНИКА
физра
Экономика
Э ИНОСТРАННЫЙ ЯЗЫК

2 семестр 2-го курса
Э СПЕЦИАЛЬНЫЕ ГЛАВЫ МАТЕМАТИЧЕСКОГО АНАЛИЗА
Э ТЕОРИЯ ВЕРОЯТНОСТИ  И МАТЕМАТИЧЕСКАЯ СТАТИСТИКА
Э ВЫЧИСЛИТЕЛЬНАЯ МАТЕМАТИКА
Э ЭЛЕКТРОТЕХНИКА, ЭЛЕКТРОНИКА И СХЕМОТЕХНИКА
Э АРХИТЕКТУРА ЭВМ
ВИЗУАЛЬНОЕ ПРОГРАММИРОВАНИЕ И ЧЕЛОВЕКО-МАШИННОЕ ВЗАИМОДЕЙСТВИЕ
РУССКИЙ ЯЗЫК И КУЛЬТУРА РЕЧИ
физра

#include <time.h>
srand(time(NULL));//in main
int i = srand();

Функция ceil(double x) округляет число x в большую сторону, а floor(doudle x) - в меньшую, 
round - математически правильное, trunc - отбросит дробную часть . Перед их использованием надо подключить заголовочный файл math.h
int m = ceil((5 + 5) / (double)3);//результат м = 4